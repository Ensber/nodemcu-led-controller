-- deathstar trashcompactor
-- compacts a folder into a c++ headder file

-- USAGE: lua dstc.lua

require("lfs")

function jsLzw(str)
  hs = ""
  -- convert string to hex
  for i=1,#str do
    local sb = string.byte(str,i,i)
    local to = string.format("%x",sb)
    if #to == 1 then to = "0" .. to end
    hs = hs .. to
  end

  -- dirty, but idc at this point
  -- run js lzw compression
  local p = io.popen("node lzw.js "..hs,"r")
  local out = p:read("*all")
  p:close()

  return out
end

switches = {}
args = {...}
for _,v in pairs(args) do
  if v:find("-",1,1) then
    switches[v:sub(2,-1)] = true
  end
end

specialHandler = {}
function specialHandler.html(data)
  local dl = #data
  -- trim data
  data:gsub("\t","    ") -- spaces in front and after are deleted later
  data = data:gsub("\r","")
  repeat
    n = 0
    data, np = data:gsub(" \n","\n"); n = n + np
    data, np = data:gsub("\n ","\n"); n = n + np
    data, np = data:gsub(" {","{"); n = n + np
    --data, np = data:gsub(";\n",";"); n = n + np
    data, np = data:gsub(", ",","); n = n + np
    data, np = data:gsub(">\n<","><"); n = n + np
    data, np = data:gsub("\n\n","\n"); n = n + np
  until n == 0
  if #data < dl then
    print("-> trimmed to "..#data.." bytes ("..math.floor(#data/dl*100).."%)")
  end
  if #data > 2048 then
    -- compress here
    data = jsLzw(data):sub(1,-2) -- remove \n

    -- len divided by 4 because one byte is written as \xAB
    print("-> compressed to "..(#data/4).." bytes ("..math.floor(#data/4/dl*100).."% of origin)")
  end
  data = data:gsub("\n","\\n")
  data = '"' .. data:gsub("\"","\\\"") .. '"'
  return data
end
specialHandler.css = specialHandler.html

function specialHandler.png(data)
  if #data > 2048 then
    print("[ERROR] maximum length of ardui strings is 2048B, ignoring file")
    return '"IGNORED FILE BY dstc.lua"'
  end
  if switches["nopng"] then return '""' end
  local t0 = os.clock()
  local out = '"'
  local outTab = {}
  local dLen = #data
  local lastIsHex = false
  local overwriteToHexOut = false
  for i=1,dLen do
    --if i==1000 then break end -- abort to test

    sByte = string.byte(data, i)

    -- if last was a hex byte, then dont output a hex complient character
    -- since it will make the interpreter think, it is part of the last byte
    if lastIsHex and (sByte >= 0x30 and sByte <= 0x39 or -- numbers
                      sByte >= 0x41 and sByte <= 0x46 or -- A-F
                      sByte >= 0x61 and sByte <= 0x66 or -- a-f
                      sByte == 0x22 or  sByte == 0x7c    -- exclude " and \
                    ) then
      overwriteToHexOut = true
    end

    if sByte > 31 and sByte < 128 and not overwriteToHexOut then
      out = out .. string.char(sByte)
      lastIsHex = false
      overwriteToHexOut = false
    else
      local hexB = string.format("%x",sByte)
      if #hexB == 1 then hexB = "0" .. hexB end
      out = out .. "\\x" .. hexB
      lastIsHex = true
    end
    --out = out .. '+(char)' .. tostring(string.byte(data, i))
    if i%100000 == 1 then -- print status every 100kb of converted data
      io.write("\r"..math.floor(i/dLen*100).."%  ")
    end
    if i%40 == 1 then -- accelerates the conversion by not using too large strings
      table.insert(outTab, out)
      out = ""
    end
  end

  table.insert(outTab, out)
  print("\r100% time: "..(os.clock()-t0).."s")
  return table.concat( outTab ) .. '"'
end

fileCount = 0
function compact(base,path)
  path = path or ""
  local out = ""
  for file in lfs.dir("webContent") do
    if file ~= "." and file ~= ".." then
      print(base..path.."/"..file)
      f = io.open(base..path.."/"..file,"rb")
      if not f then
        out = out .. compact(base,path.."/"..file)
      else
        fileCount = fileCount + 1
        local data = f:read("*all")
        f:close()

        local ending = file
        x = ending:find("%.")
        while x do
          ending = ending:sub(x+1,-1)
          x = ending:find("%.")
        end
        
        if specialHandler[ending] then
          data = specialHandler[ending](data)
        else -- default handler
          data = data:gsub("\n","\\n")
          data = data:gsub("\r","")
          data = '"' .. data:gsub("\"","\\\"") .. '"'
        end

        out = out .. '  {"' .. path..'/'..file .. '",' .. data .. '},\n'
      end
    end
  end
  return out
end

folder = "webContent"

print("generating headder file...")
local timer = os.clock()

hData2 = compact(folder):sub(1,-3) .. " \n};"
hData1 = [[
/// AUTO GENERATED FILE ///
// src in       /webinterface/webcontent/
// generated by /webinterface/dstc.lua

#include <string>

using namespace std;

int webContentSize = ]]..fileCount..[[;
string webContent[]]..fileCount..[[][2]={
]]
hData3 = "\n\n"..[[
int findWebContent(string search) {
  for(int i = 0; i < webContentSize; i++){
    if (webContent[i][0] == search) {
      return i;
    }
  } 
  return -1;
}]]

f = io.open("../controller/"..folder..".hpp","w")
f:write(hData1)
f:write(hData2)
f:write(hData3)
f:close()
print("\n------------------------------\nfinished combining "..fileCount.." files in "..(os.clock()-timer).."s")